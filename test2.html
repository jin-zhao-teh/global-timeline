<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pacific Digital Evolution Timeline</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: linear-gradient(180deg, #0a0a0a, #1a1a1a);
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        overflow: hidden;
        color: #eee;
        height: 100vh;
      }

      .container {
        max-width: 100%;
        padding: 20px;
        height: 100vh;
        display: flex;
        flex-direction: column;
      }

      header {
        text-align: center;
        padding: 20px 0;
        z-index: 10;
        position: relative;
      }

      h1 {
        font-size: 2.8rem;
        margin-bottom: 10px;
        background: linear-gradient(to right, #00c2ff, #007bff);
        background-clip: text;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        color: transparent;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      }

      .subtitle {
        font-size: 1.2rem;
        color: #aaa;
        max-width: 800px;
        margin: 0 auto;
      }

      .controls {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin: 20px 0;
      }

      .control-btn {
        background: rgba(20, 20, 20, 0.7);
        padding: 10px 20px;
        border-radius: 30px;
        font-weight: bold;
        color: #00c2ff;
        border: 2px solid #00c2ff;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .control-btn:hover {
        background: rgba(0, 194, 255, 0.2);
        box-shadow: 0 0 15px rgba(0, 194, 255, 0.5);
      }

      .orientation-toggle {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin: 10px 0 0 0;
      }

      .toggle-btn {
        background: rgba(20, 20, 20, 0.7);
        padding: 8px 16px;
        border-radius: 20px;
        font-weight: 600;
        color: #00c2ff;
        border: 2px solid #00c2ff;
        cursor: pointer;
        transition: all 0.2s ease;
        user-select: none;
      }

      .toggle-btn.active {
        background: rgba(0, 194, 255, 0.2);
        box-shadow: 0 0 12px rgba(0, 194, 255, 0.4);
      }

      .zoom-display {
        color: #00c2ff;
        font-weight: bold;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .timeline-wrapper {
        flex: 1;
        overflow: hidden;
        position: relative;
        perspective: 1000px;
        margin-top: 20px;
      }

      .bg-stars {
        position: absolute;
        top: 0;
        left: 0;
        width: 300%;
        height: 100%;
        background: url("https://www.transparenttextures.com/patterns/stardust.png");
        background-size: 400px;
        opacity: 0.25;
        z-index: 0;
        will-change: transform;
        pointer-events: none;
      }

      .timeline-line {
        position: absolute;
        top: 50%;
        left: 0;
        height: 8px;
        width: 100%;
        background: rgba(255, 255, 255, 0.15);
        z-index: 1;
        overflow: hidden;
        pointer-events: none;
      }

      .timeline-progress {
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #00c2ff, #007bff);
        box-shadow: 0 0 12px rgba(0, 194, 255, 0.7);
        transition: width 0.1s linear;
      }

      .timeline-container {
        display: flex;
        align-items: center;
        height: 100%;
        padding: 0 100px;
        position: relative;
        will-change: transform;
        z-index: 2;
        transition: transform 0.5s ease;
      }

      .event {
        position: relative;
        flex: 0 0 600px;
        margin: 0 80px;
        text-align: center;
        transition: transform 0.5s ease, opacity 0.5s ease;
        opacity: 0.7;
        transform: scale(0.9);
      }

      .event.focused {
        opacity: 1;
        transform: scale(1.08) translateY(-10px);
        z-index: 10;
      }

      .event-icon {
        width: 100px;
        height: 100px;
        border-radius: 50%;
        background: linear-gradient(145deg, #007bff, #0056b3);
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto;
        position: relative;
        z-index: 2;
        font-size: 44px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        transition: all 0.3s ease;
        border: 3px solid rgba(255, 255, 255, 0.1);
      }

      .event.focused .event-icon {
        transform: rotate(10deg) scale(1.1);
        box-shadow: 0 8px 25px rgba(0, 123, 255, 0.6);
      }

      .event-period {
        font-weight: bold;
        color: #00c2ff;
        margin-top: 15px;
        position: relative;
        z-index: 2;
        font-size: 22px;
        text-shadow: 0 0 8px rgba(0, 194, 255, 0.6);
      }

      .event-card {
        background: rgba(20, 20, 20, 0.95);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 14px;
        padding: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        width: 450px;
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        font-size: 16px;
        line-height: 1.5;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
        opacity: 0;
        visibility: hidden;
        z-index: 20;
      }

      .event.focused .event-card {
        opacity: 1;
        visibility: visible;
      }

      .event:nth-child(odd) .event-card {
        top: 160px;
      }

      .event:nth-child(even) .event-card {
        bottom: 160px;
      }

      .event-title {
        font-size: 18px;
        color: #00c2ff;
        margin-bottom: 10px;
        font-weight: bold;
      }

      .event-description {
        font-size: 15px;
        color: #ddd;
        margin-bottom: 15px;
      }

      .event-legal {
        font-size: 13px;
        color: #aaa;
        font-style: italic;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        padding-top: 10px;
        margin-top: 10px;
      }

      .event-reference {
        display: block;
        margin-top: 15px;
        color: #00c2ff;
        text-decoration: none;
        font-size: 14px;
      }

      .event-reference:hover {
        text-decoration: underline;
      }

      .event-description.clamp {
        display: -webkit-box;
        -webkit-line-clamp: 3;
        line-clamp: 3;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }

      .read-more-btn {
        display: inline-block;
        margin-top: 8px;
        margin-bottom: 15px;
        background: transparent;
        border: none;
        color: #00c2ff;
        cursor: pointer;
        font-size: 14px;
        padding: 0;
        text-decoration: underline;
      }

      .hidden {
        display: none;
      }

      .scroll-hint {
        text-align: center;
        margin-top: 20px;
        color: #00c2ff;
        font-style: italic;
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 0.7;
        }
        50% {
          opacity: 1;
        }
      }

      .island-selector {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin: 20px 0;
        flex-wrap: wrap;
      }

      .island-btn {
        background: rgba(20, 20, 20, 0.7);
        padding: 10px 20px;
        border-radius: 30px;
        font-weight: bold;
        color: #00c2ff;
        border: 2px solid #00c2ff;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .island-btn.active {
        background: rgba(0, 194, 255, 0.2);
        box-shadow: 0 0 15px rgba(0, 194, 255, 0.5);
      }

      .timeline-scroll-container {
        width: 100%;
        height: 100%;
        overflow: auto;
        position: relative;
        scrollbar-width: none;
        -ms-overflow-style: none;
      }

      .timeline-scroll-container::-webkit-scrollbar {
        display: none;
      }

      .loading {
        text-align: center;
        color: #00c2ff;
        font-size: 1.2rem;
        margin-top: 50px;
      }

      @media (max-width: 1200px) {
        .timeline-container {
          padding: 0 80px;
        }

        .event {
          flex: 0 0 550px;
          margin: 0 60px;
        }

        .event-card {
          width: 400px;
        }
      }

      @media (max-width: 768px) {
        h1 {
          font-size: 2rem;
        }

        .subtitle {
          font-size: 1rem;
        }

        .timeline-container {
          padding: 0 20px;
        }

        .event {
          flex: 0 0 300px;
          margin: 0 20px;
        }

        .event-card {
          width: 280px;
          padding: 15px;
        }

        .event:nth-child(odd) .event-card,
        .event:nth-child(even) .event-card {
          position: fixed;
          bottom: 20px;
          top: auto;
          left: 50%;
          transform: translateX(-50%);
          width: 90%;
          max-width: 320px;
        }

        .island-btn {
          padding: 8px 16px;
          font-size: 0.9rem;
        }

        .event-icon {
          width: 80px;
          height: 80px;
          font-size: 36px;
        }

        .event-period {
          font-size: 18px;
        }
      }

      /* Vertical mode overrides */
      .vertical-mode .timeline-line {
        top: 0;
        left: 50%;
        transform: translateX(-50%);
        width: 8px;
        height: 100%;
      }

      .vertical-mode .timeline-progress {
        top: 0;
        left: 0;
        width: 100%;
        height: 0%;
        background: linear-gradient(180deg, #00c2ff, #007bff);
        transition: height 0.1s linear;
      }

      .vertical-mode .timeline-container {
        --center-gap: clamp(180px, 18vw, 420px);
        --event-gap: clamp(400px, 50vh, 800px);
        --icon-radius: 53px;
        flex-direction: column;
        align-items: center;
        height: auto;
        padding: clamp(120px, 12vh, 240px) 0;
      }

      .vertical-mode .timeline-scroll-container {
        overflow-y: auto;
        overflow-x: hidden;
      }

      .vertical-mode .event {
        position: relative;
        flex: 0 0 auto;
        margin: var(--event-gap) 0;
        padding-block: clamp(80px, 8vh, 160px);
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        min-height: 200px;
      }

      .vertical-mode .event-card {
        position: absolute;
        transform: translateY(-50%);
        width: clamp(260px, 40vw, 560px);
        opacity: 1;
        visibility: visible;
        z-index: 30;
        pointer-events: auto;
        left: auto;
        right: auto;
        max-height: none;
        overflow: visible;
      }

      .vertical-mode .event:nth-child(odd) .event-card {
        left: calc(50% + var(--center-gap));
        text-align: left;
      }

      .vertical-mode .event:nth-child(even) .event-card {
        right: calc(50% + var(--center-gap));
        text-align: right;
        left: auto;
        transform: translateY(-50%);
      }

      .vertical-mode .event .event-icon,
      .vertical-mode .event .event-period {
        margin-left: auto;
        margin-right: auto;
      }

      .vertical-mode .event .event-period {
        order: 0;
        margin-bottom: 12px;
      }

      .vertical-mode .event .event-icon {
        order: 1;
      }

      .vertical-mode .event .event-icon::after {
        content: "";
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        width: calc(var(--center-gap) - var(--icon-radius));
        height: 2px;
        background: rgba(255, 255, 255, 0.25);
        pointer-events: none;
      }

      .vertical-mode .event:nth-child(odd) .event-icon::after {
        left: calc(50% + var(--icon-radius));
      }

      .vertical-mode .event:nth-child(even) .event-icon::after {
        right: calc(50% + var(--icon-radius));
      }

      @media (max-width: 1024px) {
        .vertical-mode .event-card {
          width: clamp(240px, 35vw, 400px);
        }

        .vertical-mode .event:nth-child(odd) .event-card {
          left: calc(50% + 120px);
        }

        .vertical-mode .event:nth-child(even) .event-card {
          right: calc(50% + 120px);
        }

        .vertical-mode .event .event-icon::after {
          width: calc(120px - var(--icon-radius));
        }
      }

      @media (max-width: 768px) {
        .vertical-mode .event-card {
          position: fixed;
          bottom: 20px;
          top: auto;
          left: 50%;
          transform: translateX(-50%);
          width: 90%;
          max-width: 320px;
        }

        .vertical-mode .event:nth-child(odd) .event-card,
        .vertical-mode .event:nth-child(even) .event-card {
          left: 50%;
          right: auto;
          text-align: left;
        }

        .vertical-mode .event .event-icon::after {
          display: none;
        }
      }
    </style>
  </head>
  <body class="vertical-mode">
    <div class="container">
      <header>
        <h1>Pacific Digital Evolution Timeline</h1>
        <p class="subtitle">
          From colonial administration to digital transformation in the Cook
          Islands, Niue, and Tokelau
        </p>
        <div class="orientation-toggle" aria-label="Timeline orientation">
          <button id="btn-vertical" class="toggle-btn active" type="button">
            <i class="fas fa-arrows-up-down"></i> Vertical
          </button>
          <button id="btn-horizontal" class="toggle-btn" type="button">
            <i class="fas fa-arrows-left-right"></i> Horizontal
          </button>
        </div>
      </header>

      <div class="island-selector">
        <div class="island-btn active" data-island="all">All Islands</div>
        <div class="island-btn" data-island="cook">Cook Islands</div>
        <div class="island-btn" data-island="niue">Niue</div>
        <div class="island-btn" data-island="tokelau">Tokelau</div>
      </div>

      <div class="scroll-hint" id="scroll-hint">
        <i id="scroll-hint-icon" class="fas fa-arrows-up-down"></i>
        <span id="scroll-hint-text"
          >Scroll vertically to navigate the timeline</span
        >
      </div>

      <div class="timeline-wrapper">
        <div class="bg-stars" id="bg"></div>
        <div class="timeline-line">
          <div class="timeline-progress" id="progress"></div>
        </div>
        <div class="timeline-scroll-container" id="scroll-container">
          <div class="timeline-container" id="timeline">
            <div class="loading">Loading timeline data...</div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Timeline data - using a sample for demonstration
      const timelineData = {
        timelineData: [
          {
            period: "1901-1950",
            icon: '<i class="fas fa-crown"></i>',
            title: "Colonial Administration",
            description:
              "During this period, the Cook Islands, Niue, and Tokelau were under New Zealand administration. Communication was limited to traditional methods and basic telegraph systems. Infrastructure development was minimal, focusing primarily on administrative needs rather than public services.",
            legal:
              "New Zealand assumed administrative control through various acts of parliament.",
            reference: "#",
            islands: ["cook", "niue", "tokelau"],
          },
          {
            period: "1950s-1960s",
            icon: '<i class="fas fa-radio"></i>',
            title: "Radio Communication",
            description:
              "Introduction of radio communication systems for administrative and emergency purposes. This technology significantly improved communication between islands and with New Zealand. Radio stations were established in each territory, providing news and information to the public.",
            legal:
              "Communication systems were government-controlled and operated.",
            reference: "#",
            islands: ["cook", "niue", "tokelau"],
          },
          {
            period: "1970s-1980s",
            icon: '<i class="fas fa-phone"></i>',
            title: "Telephone Services",
            description:
              "Basic telephone services were introduced, initially for government use and later expanding to the public. This period saw the establishment of the first telephone exchanges and the beginning of a more connected society across the islands.",
            legal:
              "Telecommunications were managed by New Zealand Post Office initially.",
            reference: "#",
            islands: ["cook", "niue"],
          },
          {
            period: "1990s",
            icon: '<i class="fas fa-satellite"></i>',
            title: "Satellite Communication",
            description:
              "Satellite technology improved connectivity, enabling better international communication and the first internet connections. This era marked the beginning of digital transformation with the introduction of email and basic online services.",
            legal:
              "Telecommunications sector reforms began in the Pacific region.",
            reference: "#",
            islands: ["cook", "niue", "tokelau"],
          },
          {
            period: "2000s",
            icon: '<i class="fas fa-laptop"></i>',
            title: "Internet Access",
            description:
              "Commercial internet services became available, leading to the establishment of cybercaf√©s and later home internet connections. This decade saw the first websites dedicated to Pacific Island news and services.",
            legal:
              "Various telecommunications acts established regulatory frameworks.",
            reference: "#",
            islands: ["cook", "niue"],
          },
          {
            period: "2010s",
            icon: '<i class="fas fa-mobile-alt"></i>',
            title: "Mobile Revolution",
            description:
              "Mobile networks expanded rapidly, with 3G and later 4G services becoming available. Smartphone adoption increased dramatically, changing how people communicate and access information.",
            legal:
              "Competition in telecommunications markets increased accessibility.",
            reference: "#",
            islands: ["cook", "niue"],
          },
          {
            period: "2020s",
            icon: '<i class="fas fa-cloud"></i>',
            title: "Digital Transformation",
            description:
              "Focus on digital government services, online education, and e-commerce. The COVID-19 pandemic accelerated digital adoption, with increased reliance on digital platforms for work, education, and social connection.",
            legal:
              "Data protection and digital sovereignty issues gained prominence.",
            reference: "#",
            islands: ["cook", "niue", "tokelau"],
          },
        ],
      };

      // DOM elements
      const timeline = document.getElementById("timeline");
      const scrollContainer = document.getElementById("scroll-container");
      const bg = document.getElementById("bg");
      const progress = document.getElementById("progress");
      const islandBtns = document.querySelectorAll(".island-btn");
      const btnVertical = document.getElementById("btn-vertical");
      const btnHorizontal = document.getElementById("btn-horizontal");
      const scrollHint = document.getElementById("scroll-hint");
      const scrollHintIcon = document.getElementById("scroll-hint-icon");
      const scrollHintText = document.getElementById("scroll-hint-text");

      // Variables
      let events = [];
      let orientation = "vertical";
      let scrollX = 0;
      let scrollY = 0;
      let velocity = 0;
      let isDragging = false;
      let startX = 0;
      let startY = 0;
      let currentIsland = "all";
      let focusedEventIndex = -1;
      let zoomLevel = 1.0;
      let rafId = null;
      let lastScrollTime = 0;
      let resizeObservers = [];
      let mutationObservers = [];

      // Initialize the timeline
      function initTimeline() {
        // Clear loading message
        timeline.innerHTML = "";

        // Create event elements from data
        timelineData.timelineData.forEach((eventData) => {
          const eventElement = document.createElement("div");
          eventElement.className = "event";
          eventElement.setAttribute(
            "data-islands",
            eventData.islands.join(" ")
          );

          // Build card with truncation and read more
          const fullDesc = eventData.description || "";
          const shouldClamp = fullDesc.length > 220;
          const clampedClass = shouldClamp ? "clamp" : "";

          eventElement.innerHTML = `
            <div class="event-icon">${eventData.icon}</div>
            <div class="event-period">${eventData.period}</div>
            <div class="event-card">
              <div class="event-title">${eventData.title}</div>
              <p class="event-description ${clampedClass}">${fullDesc}</p>
              ${
                shouldClamp
                  ? '<button class="read-more-btn" type="button">Read more</button>'
                  : ""
              }
              <a href="${
                eventData.reference
              }" target="_blank" class="event-reference">
                <i class="fas fa-external-link-alt"></i> Reference
              </a>
              <p class="event-legal ${shouldClamp ? "hidden" : ""}">${
            eventData.legal
          }</p>
            </div>
          `;

          timeline.appendChild(eventElement);
        });

        // Update events list
        events = document.querySelectorAll(".event");

        // Initialize the rest of the functionality
        setupEventListeners();
        filterEvents("all");
        updateZoom();
        setupNativeScrolling();
        bindReadMoreButtons();
        updateScrollHint();
        alignCardsVertically();
        setupAlignmentObservers();
      }

      // Setup event listeners
      function setupEventListeners() {
        // Orientation toggle
        btnVertical.addEventListener("click", () => setOrientation("vertical"));
        btnHorizontal.addEventListener("click", () =>
          setOrientation("horizontal")
        );

        // Island filter buttons
        islandBtns.forEach((btn) => {
          btn.addEventListener("click", function () {
            islandBtns.forEach((b) => b.classList.remove("active"));
            this.classList.add("active");
            filterEvents(this.getAttribute("data-island"));
          });
        });

        // Mouse wheel scrolling with momentum (horizontal only)
        scrollContainer.addEventListener(
          "wheel",
          (e) => {
            if (orientation === "horizontal") {
              e.preventDefault();
              velocity += e.deltaY * 1.2;
              if (!rafId && Math.abs(velocity) > 1) {
                lastScrollTime = 0;
                rafId = requestAnimationFrame(animate);
              }
            }
          },
          { passive: false }
        );

        // Touch events for mobile
        scrollContainer.addEventListener("touchstart", (e) => {
          isDragging = true;
          startX = e.touches[0].clientX - scrollX;
          startY = e.touches[0].clientY - scrollY;
          velocity = 0;
        });

        scrollContainer.addEventListener("touchmove", (e) => {
          if (!isDragging) return;
          if (orientation === "horizontal") {
            e.preventDefault();
            const x = e.touches[0].clientX;
            scrollX = x - startX;
            scrollContainer.scrollLeft = scrollX;
          }
        });

        scrollContainer.addEventListener("touchend", () => {
          isDragging = false;
          if (orientation === "horizontal") {
            if (Math.abs(velocity) > 1) {
              lastScrollTime = 0;
              rafId = requestAnimationFrame(animate);
            }
          }
        });

        // Mouse drag for desktop
        scrollContainer.addEventListener("mousedown", (e) => {
          isDragging = true;
          startX = e.clientX - scrollX;
          startY = e.clientY - scrollY;
          velocity = 0;
          scrollContainer.style.cursor = "grabbing";
        });

        window.addEventListener("mousemove", (e) => {
          if (!isDragging) return;
          if (orientation === "horizontal") {
            const x = e.clientX;
            scrollX = x - startX;
            scrollContainer.scrollLeft = scrollX;
          }
        });

        window.addEventListener("mouseup", () => {
          isDragging = false;
          scrollContainer.style.cursor = "grab";
          if (orientation === "horizontal") {
            if (Math.abs(velocity) > 1) {
              lastScrollTime = 0;
              rafId = requestAnimationFrame(animate);
            }
          }
        });

        // Handle window resize
        window.addEventListener("resize", () => {
          updateEventFocus();
          alignCardsVertically();
        });

        // Also ensure alignment after window load (fonts/images)
        window.addEventListener("load", () => {
          scheduleAlign();
        });
      }

      function updateEventFocus() {
        const timelineCenterX = window.innerWidth / 2;
        const timelineCenterY = window.innerHeight / 2;

        events.forEach((event, index) => {
          if (event.style.display === "none") return;

          const eventRect = event.getBoundingClientRect();
          const eventCenterX = eventRect.left + eventRect.width / 2;
          const eventCenterY = eventRect.top + eventRect.height / 2;

          // Calculate distance from center depending on orientation
          const distance =
            orientation === "horizontal"
              ? Math.abs(timelineCenterX - eventCenterX)
              : Math.abs(timelineCenterY - eventCenterY);

          const threshold =
            orientation === "horizontal"
              ? eventRect.width / 2
              : eventRect.height / 2;

          if (distance < threshold) {
            event.classList.add("focused");
            focusedEventIndex = index;
          } else {
            event.classList.remove("focused");
          }
        });
      }

      function filterEvents(island) {
        currentIsland = island;

        events.forEach((event) => {
          const eventIslands = event.getAttribute("data-islands").split(" ");

          if (island === "all" || eventIslands.includes(island)) {
            event.style.display = "flex";
          } else {
            event.style.display = "none";
            event.classList.remove("focused");
          }
        });

        // Reset scroll position after filtering
        scrollContainer.scrollLeft = 0;
        scrollContainer.scrollTop = 0;
        scrollX = 0;
        scrollY = 0;
        velocity = 0;
        updateZoom();
        // Re-align and reattach observers after layout changes
        scheduleAlign();
        setupAlignmentObservers();
      }

      function updateZoom() {
        // Adjust event spacing based on zoom level
        events.forEach((event) => {
          if (event.style.display !== "none") {
            // Increase spacing with zoom level
            const spacing = 80 * zoomLevel;
            event.style.margin = `0 ${spacing}px`;

            // Scale event size
            const scale = 1 / zoomLevel;
            event.style.transform = `scale(${scale})`;

            if (event.classList.contains("focused")) {
              event.style.transform = `scale(${
                scale * 1.08
              }) translateY(-10px)`;
            }
          }
        });

        // Adjust timeline container scale (only in horizontal mode for now)
        if (orientation === "horizontal") {
          timeline.style.transform = `scale(${1 / zoomLevel})`;
          timeline.style.transformOrigin = "0 50%";
        } else {
          timeline.style.transform = "none";
        }
      }

      function animate(timestamp) {
        if (!lastScrollTime) lastScrollTime = timestamp;
        const elapsed = timestamp - lastScrollTime;

        // Only update at 60fps for smoother animation
        if (elapsed > 16) {
          // Apply velocity
          if (orientation === "horizontal") {
            scrollX += velocity;
          }

          // Apply friction
          velocity *= 0.87;

          // Stop animation if velocity is very small
          if (Math.abs(velocity) < 0.1) {
            velocity = 0;
          }

          const maxScroll =
            orientation === "horizontal"
              ? timeline.scrollWidth * zoomLevel - window.innerWidth
              : timeline.scrollHeight - window.innerHeight;

          // Bounce back when beyond boundaries
          if (orientation === "horizontal") {
            if (scrollX < -300) {
              scrollX = -300;
              velocity = -velocity * 0.5;
            } else if (scrollX > maxScroll + 300) {
              scrollX = maxScroll + 300;
              velocity = -velocity * 0.5;
            }
          }

          // Apply gentle pull when beyond normal boundaries
          if (orientation === "horizontal") {
            if (scrollX < 0) {
              velocity += -scrollX * 0.15;
            } else if (scrollX > maxScroll) {
              velocity += (maxScroll - scrollX) * 0.15;
            }
          }

          // Update visuals
          if (orientation === "horizontal") {
            scrollContainer.scrollLeft = scrollX;
            bg.style.transform = `translateX(${-scrollX * 0.3}px)`;
          }

          // Update progress bar (clamped between 0 and 100%)
          const clampedScroll = Math.min(
            Math.max(orientation === "horizontal" ? scrollX : scrollY, 0),
            maxScroll
          );
          const progressPercent =
            maxScroll > 0 ? (clampedScroll / maxScroll) * 100 : 0;
          if (orientation === "horizontal") {
            progress.style.width = `${progressPercent}%`;
          } else {
            progress.style.height = `${progressPercent}%`;
          }

          // Update which event is focused
          updateEventFocus();

          lastScrollTime = timestamp;
        }

        rafId = requestAnimationFrame(animate);
      }

      // Use native scrolling for a more natural feel
      function setupNativeScrolling() {
        scrollContainer.addEventListener("scroll", (e) => {
          if (orientation === "horizontal") {
            scrollX = scrollContainer.scrollLeft;
            const maxScroll =
              timeline.scrollWidth * zoomLevel - window.innerWidth;
            const progressPercent =
              maxScroll > 0 ? (scrollX / maxScroll) * 100 : 0;
            progress.style.width = `${progressPercent}%`;
            bg.style.transform = `translateX(${-scrollX * 0.3}px)`;
          } else {
            scrollY = scrollContainer.scrollTop;
            const maxScroll = timeline.scrollHeight - window.innerHeight;
            const progressPercent =
              maxScroll > 0 ? (scrollY / maxScroll) * 100 : 0;
            progress.style.height = `${progressPercent}%`;
            bg.style.transform = `translateY(${-scrollY * 0.15}px)`;
          }

          updateEventFocus();
        });

        // Cancel the custom animation
        if (rafId) {
          cancelAnimationFrame(rafId);
          rafId = null;
        }
      }

      function setOrientation(mode) {
        if (mode === orientation) return;
        orientation = mode;

        // Toggle button states
        btnVertical.classList.toggle("active", orientation === "vertical");
        btnHorizontal.classList.toggle("active", orientation === "horizontal");

        // Toggle body class for CSS overrides
        document.body.classList.toggle(
          "vertical-mode",
          orientation === "vertical"
        );

        // Reset scroll positions and visuals
        scrollContainer.scrollLeft = 0;
        scrollContainer.scrollTop = 0;
        scrollX = 0;
        scrollY = 0;
        velocity = 0;

        // Reset progress bar
        progress.style.width = orientation === "horizontal" ? "0%" : "100%";
        progress.style.height = orientation === "horizontal" ? "100%" : "0%";

        updateZoom();
        updateEventFocus();
        updateScrollHint();
        alignCardsVertically();
        setupAlignmentObservers();
      }

      function updateScrollHint() {
        if (orientation === "horizontal") {
          scrollHintIcon.className = "fas fa-arrows-left-right";
          scrollHintText.textContent =
            "Scroll horizontally to navigate the timeline";
        } else {
          scrollHintIcon.className = "fas fa-arrows-up-down";
          scrollHintText.textContent =
            "Scroll vertically to navigate the timeline";
        }
      }

      function bindReadMoreButtons() {
        const buttons = document.querySelectorAll(".read-more-btn");
        buttons.forEach((btn) => {
          btn.addEventListener("click", (e) => {
            const card = e.target.closest(".event-card");
            const desc = card.querySelector(".event-description");
            const legal = card.querySelector(".event-legal");
            const isClamped = desc.classList.contains("clamp");
            if (isClamped) {
              desc.classList.remove("clamp");
              e.target.textContent = "Read less";
              if (legal) legal.classList.remove("hidden");
            } else {
              desc.classList.add("clamp");
              e.target.textContent = "Read more";
              if (legal) legal.classList.add("hidden");
            }
            // Re-align after content height changes
            scheduleAlign();
          });
        });
      }

      // Align each event card's vertical center to its icon center in vertical mode
      function alignCardsVertically() {
        if (orientation !== "vertical") return;

        document.querySelectorAll(".vertical-mode .event").forEach((ev) => {
          const card = ev.querySelector(".event-card");
          const icon = ev.querySelector(".event-icon");
          if (!card || !icon) return;

          // Reset height for accurate measurement
          ev.style.minHeight = "0px";

          // Get card height
          const cardHeight = card.offsetHeight;

          // Align card vertically with icon
          const iconCenter = icon.offsetTop + icon.offsetHeight / 2;
          card.style.top = iconCenter + "px";

          // Ensure container fully contains the card
          ev.style.minHeight = cardHeight + 120 + "px";
        });
      }

      // Batch and schedule alignment using double rAF for layout stability
      function scheduleAlign() {
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            alignCardsVertically();
          });
        });
      }

      // Observe size/content changes to keep cards aligned
      function setupAlignmentObservers() {
        // Clean up existing observers
        resizeObservers.forEach((ro) => ro.disconnect());
        mutationObservers.forEach((mo) => mo.disconnect());
        resizeObservers = [];
        mutationObservers = [];

        if (orientation !== "vertical") return;
        if (!("ResizeObserver" in window)) {
          scheduleAlign();
          return;
        }

        events.forEach((ev) => {
          if (ev.style.display === "none") return;
          const icon = ev.querySelector(".event-icon");
          const card = ev.querySelector(".event-card");
          if (!icon || !card) return;

          const ro = new ResizeObserver(() => scheduleAlign());
          ro.observe(icon);
          ro.observe(card);
          resizeObservers.push(ro);

          // Mutation observer for content changes inside the card
          const mo = new MutationObserver(() => scheduleAlign());
          mo.observe(card, {
            childList: true,
            subtree: true,
            characterData: true,
          });
          mutationObservers.push(mo);
        });
      }

      // Initialize the timeline when the DOM is loaded
      document.addEventListener("DOMContentLoaded", initTimeline);
    </script>
  </body>
</html>
