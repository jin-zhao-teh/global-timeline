<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pacific Digital Evolution Timeline</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }


      body {
        background: linear-gradient(180deg, #0a0a0a, #1a1a1a);
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        overflow: hidden;
        color: #eee;
        height: 100vh;
      }

      .container {
        max-width: 100%;
        padding: 20px;
        height: 100vh;
        display: flex;
        flex-direction: column;
      }

      header {
        text-align: center;
        padding: 20px 0;
        z-index: 10;
        position: relative;
      }

      h1 {
        font-size: 2.8rem;
        margin-bottom: 10px;
        background: linear-gradient(to right, #00c2ff, #007bff);
        background-clip: text; /* standard */
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        color: transparent; /* non-webkit fallback */
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      }

      .subtitle {
        font-size: 1.2rem;
        color: #aaa;
        max-width: 800px;
        margin: 0 auto;
      }

      .controls {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin: 20px 0;
      }

      .control-btn {
        background: rgba(20, 20, 20, 0.7);
        padding: 10px 20px;
        border-radius: 30px;
        font-weight: bold;
        color: #00c2ff;
        border: 2px solid #00c2ff;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .control-btn:hover {
        background: rgba(0, 194, 255, 0.2);
        box-shadow: 0 0 15px rgba(0, 194, 255, 0.5);
      }

      /* Orientation toggle */
      .orientation-toggle {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin: 10px 0 0 0;
      }

      .toggle-btn {
        background: rgba(20, 20, 20, 0.7);
        padding: 8px 16px;
        border-radius: 20px;
        font-weight: 600;
        color: #00c2ff;
        border: 2px solid #00c2ff;
        cursor: pointer;
        transition: all 0.2s ease;
        user-select: none;
      }

      .toggle-btn.active {
        background: rgba(0, 194, 255, 0.2);
        box-shadow: 0 0 12px rgba(0, 194, 255, 0.4);
      }

      .zoom-display {
        color: #00c2ff;
        font-weight: bold;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .timeline-wrapper {
        flex: 1;
        overflow: hidden;
        position: relative;
        perspective: 1000px;
        margin-top: 20px;
      }

      .bg-stars {
        position: absolute;
        top: 0;
        left: 0;
        width: 300%;
        height: 100%;
        background: url("https://www.transparenttextures.com/patterns/stardust.png");
        background-size: 400px;
        opacity: 0.25;
        z-index: 0;
        will-change: transform;
        pointer-events: none;
      }

      .timeline-line {
        position: absolute;
        top: 50%;
        left: 0;
        height: 8px;
        width: 100%;
        background: rgba(255, 255, 255, 0.15);
        z-index: 1;
        overflow: hidden;
        pointer-events: none; /* do not block clicks */
      }

      .timeline-progress {
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #00c2ff, #007bff);
        box-shadow: 0 0 12px rgba(0, 194, 255, 0.7);
        transition: width 0.1s linear;
      }

      .timeline-container {
        display: flex;
        align-items: center;
        height: 100%;
        padding: 0 100px;
        position: relative;
        will-change: transform;
        z-index: 2;
        transition: transform 0.5s ease;
      }

      .event {
        position: relative;
        flex: 0 0 600px;
        margin: 0 80px;
        text-align: center;
        transition: transform 0.5s ease, opacity 0.5s ease;
        opacity: 0.7;
        transform: scale(0.9);
      }

      .event.focused {
        opacity: 1;
        transform: scale(1.08) translateY(-10px);
        z-index: 10;
      }

      .event-icon {
        width: 100px;
        height: 100px;
        border-radius: 50%;
        background: linear-gradient(145deg, #007bff, #0056b3);
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto;
        position: relative;
        z-index: 2;
        font-size: 44px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        transition: all 0.3s ease;
        border: 3px solid rgba(255, 255, 255, 0.1);
      }

      .event.focused .event-icon {
        transform: rotate(10deg) scale(1.1);
        box-shadow: 0 8px 25px rgba(0, 123, 255, 0.6);
      }

      .event-period {
        font-weight: bold;
        color: #00c2ff;
        margin-top: 15px;
        position: relative;
        z-index: 2;
        font-size: 22px;
        text-shadow: 0 0 8px rgba(0, 194, 255, 0.6);
      }

      .event-card {
        background: rgba(20, 20, 20, 0.95);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 14px;
        padding: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        width: 450px;
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        font-size: 16px;
        line-height: 1.5;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
        opacity: 0;
        visibility: hidden;
        z-index: 20;
      }

      .event.focused .event-card {
        opacity: 1;
        visibility: visible;
      }

      .event:nth-child(odd) .event-card {
        top: 160px;
      }

      .event:nth-child(even) .event-card {
        bottom: 160px;
      }

      .event-title {
        font-size: 18px;
        color: #00c2ff;
        margin-bottom: 10px;
        font-weight: bold;
      }

      .event-description {
        font-size: 15px;
        color: #ddd;
        margin-bottom: 15px;
      }

      .event-legal {
        font-size: 13px;
        color: #aaa;
        font-style: italic;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        padding-top: 10px;
        margin-top: 10px;
      }

      .event-reference {
        display: block;
        margin-top: 15px;
        color: #00c2ff;
        text-decoration: none;
        font-size: 14px;
      }

      .event-reference:hover {
        text-decoration: underline;
      }

      /* Truncation and read more */
      .event-description.clamp {
        display: -webkit-box;
        -webkit-line-clamp: 3;
        line-clamp: 3;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }

      .read-more-btn {
        display: inline-block;
        margin-top: 8px;
        margin-bottom: 15px;
        background: transparent;
        border: none;
        color: #00c2ff;
        cursor: pointer;
        font-size: 14px;
        padding: 0;
        text-decoration: underline;
      }

      .hidden {
        display: none;
      }

      .scroll-hint {
        text-align: center;
        margin-top: 20px;
        color: #00c2ff;
        font-style: italic;
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 0.7;
        }
        50% {
          opacity: 1;
        }
      }

      .island-selector {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin: 20px 0;
      }

      .island-btn {
        background: rgba(20, 20, 20, 0.7);
        padding: 10px 20px;
        border-radius: 30px;
        font-weight: bold;
        color: #00c2ff;
        border: 2px solid #00c2ff;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .island-btn.active {
        background: rgba(0, 194, 255, 0.2);
        box-shadow: 0 0 15px rgba(0, 194, 255, 0.5);
      }

      .timeline-scroll-container {
        width: 100%;
        height: 100%;
        overflow: auto;
        position: relative;
        scrollbar-width: none;
        -ms-overflow-style: none;
      }

      .timeline-scroll-container::-webkit-scrollbar {
        display: none;
      }

      .loading {
        text-align: center;
        color: #00c2ff;
        font-size: 1.2rem;
        margin-top: 50px;
      }

      @media (max-width: 1200px) {
        .timeline-container {
          padding: 0 80px;
        }

        .event {
          flex: 0 0 550px;
          margin: 0 60px;
        }

        .event-card {
          width: 400px;
        }
      }

      @media (max-width: 768px) {
        .timeline-container {
          padding: 0 40px;
        }

        .event {
          flex: 0 0 400px;
          margin: 0 40px;
        }

        .event-card {
          width: 320px;
          padding: 15px;
        }

        .event:nth-child(odd) .event-card,
        .event:nth-child(even) .event-card {
          position: fixed;
          bottom: 20px;
          top: auto;
          left: 50%;
          transform: translateX(-50%);
          width: 90%;
          max-width: 320px;
        }
      }

      /* ============================= */
      /* Vertical mode overrides       */
      /* ============================= */
      .vertical-mode .timeline-line {
        top: 0;
        left: 50%;
        transform: translateX(-50%);
        width: 8px;
        height: 100%;
      }

      .vertical-mode .timeline-progress {
        top: 0;
        left: 0;
        width: 100%;
        height: 0%;
        background: linear-gradient(180deg, #00c2ff, #007bff);
        transition: height 0.1s linear;
      }

      .vertical-mode .timeline-container {
        /* Responsive variables */
        --center-gap: clamp(180px, 18vw, 420px); /* responsive horizontal gap from center to card; larger on ultrawide */
        --event-gap: clamp(700px, max(120vh, 90vw), 2600px); /* responsive vertical distance between events */
        --icon-radius: 53px; /* icon 100px + 3px border -> ~53px radius */
        flex-direction: column;
        align-items: center;
        height: auto;
        padding: clamp(240px, 24vh, 520px) 0; /* extra top/bottom space so first/last cards aren't clipped */
      }

      .vertical-mode .timeline-scroll-container {
        overflow-y: auto;
        overflow-x: hidden;
      }

      .vertical-mode .event {
        position: relative;
        flex: 0 0 auto;
        margin: var(--event-gap) 0; /* responsive vertical distance for more scrolling */
        min-height: clamp(420px, 48vh, 720px); /* ensure room for tall cards on both sides */
        padding-block: clamp(120px, 10vh, 220px); /* inner clearance to avoid clipping when cards expand */
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center; /* center on middle line */
        width: 100%; /* ensure absolute-positioned cards can align to page center */
      }

      .vertical-mode .event-card {
        position: absolute;
        /* Top will be set dynamically to the icon center via JS for perfect alignment */
        transform: translateY(-50%);
        width: clamp(260px, 40vw, 560px);
        opacity: 1;
        visibility: visible;
        z-index: 30; /* above timeline line and icons */
        pointer-events: auto;
        /* Reset any inherited horizontal centering from base rules */
        left: auto;
        right: auto;
        max-height: none;
        overflow: visible;
      }

      .vertical-mode .event:nth-child(odd) .event-card {
        right: auto;
        left: calc(50% + var(--center-gap)); /* right side, clear icon */
        transform: translateY(-50%); /* keep vertical centering */
        text-align: left;
      }

      .vertical-mode .event:nth-child(even) .event-card {
        right: auto;
        left: auto;
        transform: translate(-100%, -50%);
        margin-left: -20px; /* give a little offset so it's not flush */
        text-align: left;
        
        /* NEW: ensure container can grow wide enough */
        max-width: clamp(260px, 40vw, 560px);
        min-width: 260px;
      }

      /* keep icon and period centered on the middle timeline */
      .vertical-mode .event .event-icon,
      .vertical-mode .event .event-period {
        margin-left: auto;
        margin-right: auto;
      }

      /* Date above icon on the center line */
      .vertical-mode .event .event-period {
        order: 0;
        margin-bottom: 12px;
      }

      .vertical-mode .event .event-icon {
        order: 1;
      }

      /* connector line from icon to card - draw from icon center so it's perfectly centered */
      .vertical-mode .event .event-icon::after {
        content: "";
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        width: calc(var(--center-gap) - var(--icon-radius));
        height: 2px;
        background: rgba(255, 255, 255, 0.25);
        pointer-events: none;
      }

      .vertical-mode .event:nth-child(odd) .event-icon::after {
        left: calc(50% + var(--icon-radius)); /* start just outside the icon edge to the right */
      }

      .vertical-mode .event:nth-child(even) .event-icon::after {
        right: calc(50% + var(--icon-radius)); /* start just outside the icon edge to the left */
      }
    </style>
  </head>
  <body class="vertical-mode">
    <div class="container">
      <header>
        <h1>Pacific Digital Evolution Timeline</h1>
        <p class="subtitle">
          From colonial administration to digital transformation in the Cook
          Islands, Niue, and Tokelau
        </p>
        <div class="orientation-toggle" aria-label="Timeline orientation">
          <button id="btn-vertical" class="toggle-btn active" type="button">
            <i class="fas fa-arrows-up-down"></i> Vertical
          </button>
          <button id="btn-horizontal" class="toggle-btn" type="button">
            <i class="fas fa-arrows-left-right"></i> Horizontal
          </button>
        </div>
      </header>

      <div class="island-selector">
        <div class="island-btn active" data-island="all">All Islands</div>
        <div class="island-btn" data-island="cook">Cook Islands</div>
        <div class="island-btn" data-island="niue">Niue</div>
        <div class="island-btn" data-island="tokelau">Tokelau</div>
      </div>

      <div class="scroll-hint" id="scroll-hint">
        <i id="scroll-hint-icon" class="fas fa-arrows-up-down"></i>
        <span id="scroll-hint-text"
          >Scroll vertically to navigate the timeline</span
        >
      </div>

      <div class="timeline-wrapper">
        <div class="bg-stars" id="bg"></div>
        <div class="timeline-line">
          <div class="timeline-progress" id="progress"></div>
        </div>
        <div class="timeline-scroll-container" id="scroll-container">
          <div class="timeline-container" id="timeline">
            <div class="loading">Loading timeline data...</div>
          </div>
        </div>
      </div>
    </div>

    <script>
      let timelineData = [];

      fetch("data.json")
        .then((response) => response.json())
        .then((data) => {
          timelineData = data.timelineData;
          console.log(timelineData);
          initTimeline();
        })
        .catch((error) => {
          console.error("Error loading timeline data:", error);
          timeline.innerHTML =
            '<div class="loading">Error loading timeline data. Please try again later.</div>';
        });

      // DOM elements
      const timeline = document.getElementById("timeline");
      const scrollContainer = document.getElementById("scroll-container");
      const bg = document.getElementById("bg");
      const progress = document.getElementById("progress");
      const islandBtns = document.querySelectorAll(".island-btn");
      const btnVertical = document.getElementById("btn-vertical");
      const btnHorizontal = document.getElementById("btn-horizontal");
      const scrollHint = document.getElementById("scroll-hint");
      const scrollHintIcon = document.getElementById("scroll-hint-icon");
      const scrollHintText = document.getElementById("scroll-hint-text");

      // Variables
      let events = [];
      let orientation = "vertical"; // "vertical" | "horizontal"
      let scrollX = 0;
      let scrollY = 0;
      let velocity = 0;
      let isDragging = false;
      let startX = 0;
      let startY = 0;
      let currentIsland = "all";
      let focusedEventIndex = -1;
      let zoomLevel = 1.0;
      let rafId = null;
      let lastScrollTime = 0;

      // Initialize the timeline
      function initTimeline() {
        // Clear loading message
        timeline.innerHTML = "";

        // Create event elements from data
        timelineData.forEach((eventData) => {
          const eventElement = document.createElement("div");
          eventElement.className = "event";
          eventElement.setAttribute(
            "data-islands",
            eventData.islands.join(" ")
          );

          // Build card with truncation and read more
          const fullDesc = eventData.description || "";
          const shouldClamp = fullDesc.length > 220; // heuristic
          const clampedClass = shouldClamp ? "clamp" : "";

          eventElement.innerHTML = `
                    <div class="event-icon">${eventData.icon}</div>
                    <div class="event-period">${eventData.period}</div>
                    <div class="event-card">
                        <div class="event-title">${eventData.title}</div>
                        <p class="event-description ${clampedClass}">${fullDesc}</p>
                        ${
                          shouldClamp
                            ? '<button class="read-more-btn" type="button">Read more</button>'
                            : ""
                        }
                        <a href="${
                          eventData.reference
                        }" target="_blank" class="event-reference">
                            <i class="fas fa-external-link-alt"></i> Reference
                        </a>
                        <p class="event-legal ${shouldClamp ? "hidden" : ""}">${
            eventData.legal
          }</p>
                    </div>
                `;

          timeline.appendChild(eventElement);
        });

        // Update events list
        events = document.querySelectorAll(".event");

        // Initialize the rest of the functionality
        setupEventListeners();
        filterEvents("all");
        updateZoom();
        setupNativeScrolling();
        bindReadMoreButtons();
        updateScrollHint();
        alignCardsVertically();
        setupAlignmentObservers();
      }

      // Setup event listeners
      function setupEventListeners() {
        // Orientation toggle
        btnVertical.addEventListener("click", () => setOrientation("vertical"));
        btnHorizontal.addEventListener("click", () =>
          setOrientation("horizontal")
        );

        // Island filter buttons
        islandBtns.forEach((btn) => {
          btn.addEventListener("click", function () {
            islandBtns.forEach((b) => b.classList.remove("active"));
            this.classList.add("active");
            filterEvents(this.getAttribute("data-island"));
          });
        });

        // Mouse wheel scrolling with momentum (horizontal only)
        scrollContainer.addEventListener(
          "wheel",
          (e) => {
            if (orientation === "horizontal") {
              e.preventDefault();
              velocity += e.deltaY * 1.2;
              if (!rafId && Math.abs(velocity) > 1) {
                lastScrollTime = 0;
                rafId = requestAnimationFrame(animate);
              }
            }
          },
          { passive: false }
        );

        // Touch events for mobile
        scrollContainer.addEventListener("touchstart", (e) => {
          isDragging = true;
          startX = e.touches[0].clientX - scrollX;
          startY = e.touches[0].clientY - scrollY;
          velocity = 0;
        });

        scrollContainer.addEventListener("touchmove", (e) => {
          if (!isDragging) return;
          if (orientation === "horizontal") {
            e.preventDefault();
            const x = e.touches[0].clientX;
            scrollX = x - startX;
            scrollContainer.scrollLeft = scrollX;
          } else {
            // let native vertical scrolling happen
          }
        });

        scrollContainer.addEventListener("touchend", () => {
          isDragging = false;
          if (orientation === "horizontal") {
            if (Math.abs(velocity) > 1) {
              lastScrollTime = 0;
              rafId = requestAnimationFrame(animate);
            }
          }
        });

        // Mouse drag for desktop
        scrollContainer.addEventListener("mousedown", (e) => {
          isDragging = true;
          startX = e.clientX - scrollX;
          startY = e.clientY - scrollY;
          velocity = 0;
          scrollContainer.style.cursor = "grabbing";
        });

        window.addEventListener("mousemove", (e) => {
          if (!isDragging) return;
          if (orientation === "horizontal") {
            const x = e.clientX;
            scrollX = x - startX;
            scrollContainer.scrollLeft = scrollX;
          }
        });

        window.addEventListener("mouseup", () => {
          isDragging = false;
          scrollContainer.style.cursor = "grab";
          if (orientation === "horizontal") {
            if (Math.abs(velocity) > 1) {
              lastScrollTime = 0;
              rafId = requestAnimationFrame(animate);
            }
          }
        });

        // Handle window resize
        window.addEventListener("resize", () => {
          updateEventFocus();
          alignCardsVertically();
        });

        // Also ensure alignment after window load (fonts/images)
        window.addEventListener("load", () => {
          scheduleAlign();
        });
      }

      function updateEventFocus() {
        const timelineCenterX = window.innerWidth / 2;
        const timelineCenterY = window.innerHeight / 2;

        events.forEach((event, index) => {
          if (event.style.display === "none") return;

          const eventRect = event.getBoundingClientRect();
          const eventCenterX = eventRect.left + eventRect.width / 2;
          const eventCenterY = eventRect.top + eventRect.height / 2;

          // Calculate distance from center depending on orientation
          const distance =
            orientation === "horizontal"
              ? Math.abs(timelineCenterX - eventCenterX)
              : Math.abs(timelineCenterY - eventCenterY);

          const threshold =
            orientation === "horizontal"
              ? eventRect.width / 2
              : eventRect.height / 2;

          if (distance < threshold) {
            event.classList.add("focused");
            focusedEventIndex = index;
          } else {
            event.classList.remove("focused");
          }
        });
      }

      function filterEvents(island) {
        currentIsland = island;

        events.forEach((event) => {
          const eventIslands = event.getAttribute("data-islands").split(" ");

          if (island === "all" || eventIslands.includes(island)) {
            event.style.display = "flex";
          } else {
            event.style.display = "none";
            event.classList.remove("focused");
          }
        });

        // Reset scroll position after filtering
        scrollContainer.scrollLeft = 0;
        scrollContainer.scrollTop = 0;
        scrollX = 0;
        scrollY = 0;
        velocity = 0;
        updateZoom();
        // Re-align and reattach observers after layout changes
        scheduleAlign();
        setupAlignmentObservers();
      }

      function updateZoom() {
        // Adjust event spacing based on zoom level
        events.forEach((event) => {
          if (event.style.display !== "none") {
            // Increase spacing with zoom level
            const spacing = 80 * zoomLevel;
            event.style.margin = `0 ${spacing}px`;

            // Scale event size
            const scale = 1 / zoomLevel;
            event.style.transform = `scale(${scale})`;

            if (event.classList.contains("focused")) {
              event.style.transform = `scale(${
                scale * 1.08
              }) translateY(-10px)`;
            }
          }
        });

        // Update zoom level display

        // Adjust timeline container scale (only in horizontal mode for now)
        if (orientation === "horizontal") {
          timeline.style.transform = `scale(${1 / zoomLevel})`;
          timeline.style.transformOrigin = "0 50%";
        } else {
          timeline.style.transform = "none";
        }
      }

      function animate(timestamp) {
        if (!lastScrollTime) lastScrollTime = timestamp;
        const elapsed = timestamp - lastScrollTime;

        // Only update at 60fps for smoother animation
        if (elapsed > 16) {
          // Apply velocity
          if (orientation === "horizontal") {
            scrollX += velocity;
          }

          // Apply friction
          velocity *= 0.87;

          // Stop animation if velocity is very small
          if (Math.abs(velocity) < 0.1) {
            velocity = 0;
          }

          const maxScroll =
            orientation === "horizontal"
              ? timeline.scrollWidth * zoomLevel - window.innerWidth
              : timeline.scrollHeight - window.innerHeight;

          // Bounce back when beyond boundaries
          if (orientation === "horizontal") {
            if (scrollX < -300) {
              scrollX = -300;
              velocity = -velocity * 0.5;
            } else if (scrollX > maxScroll + 300) {
              scrollX = maxScroll + 300;
              velocity = -velocity * 0.5;
            }
          }

          // Apply gentle pull when beyond normal boundaries
          if (orientation === "horizontal") {
            if (scrollX < 0) {
              velocity += -scrollX * 0.15;
            } else if (scrollX > maxScroll) {
              velocity += (maxScroll - scrollX) * 0.15;
            }
          }

          // Update visuals
          if (orientation === "horizontal") {
            scrollContainer.scrollLeft = scrollX;
            bg.style.transform = `translateX(${-scrollX * 0.3}px)`;
          }

          // Update progress bar (clamped between 0 and 100%)
          const clampedScroll = Math.min(
            Math.max(orientation === "horizontal" ? scrollX : scrollY, 0),
            maxScroll
          );
          const progressPercent =
            maxScroll > 0 ? (clampedScroll / maxScroll) * 100 : 0;
          if (orientation === "horizontal") {
            progress.style.width = `${progressPercent}%`;
          } else {
            progress.style.height = `${progressPercent}%`;
          }

          // Update which event is focused
          updateEventFocus();

          lastScrollTime = timestamp;
        }

        rafId = requestAnimationFrame(animate);
      }

      // Use native scrolling for a more natural feel
      function setupNativeScrolling() {
        scrollContainer.addEventListener("scroll", (e) => {
          if (orientation === "horizontal") {
            scrollX = scrollContainer.scrollLeft;
            const maxScroll =
              timeline.scrollWidth * zoomLevel - window.innerWidth;
            const progressPercent =
              maxScroll > 0 ? (scrollX / maxScroll) * 100 : 0;
            progress.style.width = `${progressPercent}%`;
            bg.style.transform = `translateX(${-scrollX * 0.3}px)`;
          } else {
            scrollY = scrollContainer.scrollTop;
            const maxScroll = timeline.scrollHeight - window.innerHeight;
            const progressPercent =
              maxScroll > 0 ? (scrollY / maxScroll) * 100 : 0;
            progress.style.height = `${progressPercent}%`;
            bg.style.transform = `translateY(${-scrollY * 0.15}px)`;
          }

          updateEventFocus();
        });

        // Cancel the custom animation
        if (rafId) {
          cancelAnimationFrame(rafId);
          rafId = null;
        }
      }

      function setOrientation(mode) {
        if (mode === orientation) return;
        orientation = mode;

        // Toggle button states
        btnVertical.classList.toggle("active", orientation === "vertical");
        btnHorizontal.classList.toggle("active", orientation === "horizontal");

        // Toggle body class for CSS overrides
        document.body.classList.toggle(
          "vertical-mode",
          orientation === "vertical"
        );

        // Reset scroll positions and visuals
        scrollContainer.scrollLeft = 0;
        scrollContainer.scrollTop = 0;
        scrollX = 0;
        scrollY = 0;
        velocity = 0;

        // Reset progress bar
        progress.style.width = orientation === "horizontal" ? "0%" : "100%";
        progress.style.height = orientation === "horizontal" ? "100%" : "0%";

        updateZoom();
        updateEventFocus();
        updateScrollHint();
        alignCardsVertically();
        setupAlignmentObservers();
      }

      function updateScrollHint() {
        if (orientation === "horizontal") {
          scrollHintIcon.className = "fas fa-arrows-left-right";
          scrollHintText.textContent =
            "Scroll horizontally to navigate the timeline";
        } else {
          scrollHintIcon.className = "fas fa-arrows-up-down";
          scrollHintText.textContent =
            "Scroll vertically to navigate the timeline";
        }
      }

      function bindReadMoreButtons() {
        const buttons = document.querySelectorAll(".read-more-btn");
        buttons.forEach((btn) => {
          btn.addEventListener("click", (e) => {
            const card = e.target.closest(".event-card");
            const desc = card.querySelector(".event-description");
            const legal = card.querySelector(".event-legal");
            const isClamped = desc.classList.contains("clamp");
            if (isClamped) {
              desc.classList.remove("clamp");
              e.target.textContent = "Read less";
              if (legal) legal.classList.remove("hidden");
            } else {
              desc.classList.add("clamp");
              e.target.textContent = "Read more";
              if (legal) legal.classList.add("hidden");
            }
            // Re-align after content height changes
            scheduleAlign();
          });
        });
      }

      // Align each event card's vertical center to its icon center in vertical mode
      function alignCardsVertically() {
        if (orientation !== "vertical") return;
        if (!events || events.length === 0) return;
        
        events.forEach((ev) => {
          if (ev.style.display === "none") return;
          const icon = ev.querySelector(".event-icon");
          const card = ev.querySelector(".event-card");
          if (!icon || !card) return;
          
          // Reset height so we can measure fresh
          card.style.height = "auto";
          card.offsetHeight;
          
          const iconCenter = icon.offsetTop + icon.offsetHeight / 2;
          card.style.top = iconCenter + "px";
          
          const cardHeight = card.scrollHeight;
          const cardTop = iconCenter - cardHeight / 2;
          const cardBottom = cardTop + cardHeight;
          
          const containerPadding = 120;
          const requiredHeight = Math.max(cardBottom + containerPadding, cardHeight + 300);
          
          if (ev.style.minHeight !== requiredHeight + "px") {
            ev.style.minHeight = requiredHeight + "px";
          }
          
          // NEW: ensure the event container is wide enough for left cards
          const cardWidth = card.offsetWidth;
          if (ev.style.minWidth !== cardWidth * 2 + "px") {
            ev.style.minWidth = cardWidth * 2 + "px"; // enough room for both sides
          }
        });
      }

      // Batch and schedule alignment using double rAF for layout stability
      function scheduleAlign() {
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            alignCardsVertically();
          });
        });
      }

      // Observe size/content changes to keep cards aligned (handles Read more on left)
      let resizeObservers = [];
      let mutationObservers = [];
      function setupAlignmentObservers() {
        // Clean up existing observers
        resizeObservers.forEach((ro) => ro.disconnect());
        mutationObservers.forEach((mo) => mo.disconnect());
        resizeObservers = [];
        mutationObservers = [];

        if (!('ResizeObserver' in window)) {
          // Fallback: schedule alignment anyway
          scheduleAlign();
          return;
        }

        events.forEach((ev) => {
          if (ev.style.display === "none") return;
          const icon = ev.querySelector(".event-icon");
          const card = ev.querySelector(".event-card");
          if (!icon || !card) return;

          const ro = new ResizeObserver(() => scheduleAlign());
          ro.observe(icon);
          ro.observe(card);
          resizeObservers.push(ro);

          // Mutation observer for content changes inside the card (e.g., Read more)
          const mo = new MutationObserver(() => scheduleAlign());
          mo.observe(card, { childList: true, subtree: true, characterData: true });
          mutationObservers.push(mo);
        });
      }

      // Initialize the timeline
      initTimeline();
    </script>
  </body>
</html>
